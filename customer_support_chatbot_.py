# -*- coding: utf-8 -*-
"""Customer support chatbot .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XGEeEnnpX_W1N14uCgEU8_VYOzmehvhu
"""

from google.colab import drive
drive.mount('/content/drive')

"""Setup environment

"""

import pandas as pd
import numpy as np
import re
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import random
import json
from datetime import datetime

nltk.download('punkt')
nltk.download('stopwords')
nltk.download('wordnet')
nltk.download('averaged_perceptron_tagger')

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/sample.csv')
print("Dataset shape:", df.shape)
print("\nFirst few rows:")
print(df.head())
print("\nColumns:", df.columns.tolist())

""" Data Preprocessing and Analysis"""

class CustomerSupportAnalyzer:
    def __init__(self, df):
        self.df = df
        self.stop_words = set(stopwords.words('english'))

    def clean_text(self, text):
        if pd.isna(text):
            return ""

        text = re.sub(r'http\S+', '', text)
        text = re.sub(r'@\w+', '', text)
        text = re.sub(r'[^a-zA-Z\s]', '', text)
        text = text.lower()

        tokens = word_tokenize(text)
        tokens = [word for word in tokens if word not in self.stop_words and len(word) > 2]
        return ' '.join(tokens)

    def analyze_dataset(self):
        print("=== DATASET ANALYSIS ===")
        print(f"Total tweets: {len(self.df)}")
        print(f"Inbound tweets (customer queries): {len(self.df[self.df['inbound'] == True])}")
        print(f"Outbound tweets (support responses): {len(self.df[self.df['inbound'] == False])}")

        companies = self.df[~self.df['inbound']]['author_id'].unique()
        print(f"\nCompanies in dataset: {list(companies)}")

        return companies

analyzer = CustomerSupportAnalyzer(df)
companies = analyzer.analyze_dataset()

"""Create Training Data for Chatbot"""

import nltk
nltk.download('punkt')
nltk.download('punkt_tab')
nltk.download('stopwords')
nltk.download('wordnet')

# your ChatbotTrainer class
class ChatbotTrainer:
    def __init__(self, df):
        self.df = df
        self.vectorizer = TfidfVectorizer(max_features=1000)
        self.patterns = self._extract_patterns()

    def _extract_patterns(self):
        patterns = {
            'greeting': {
                'patterns': ['hello', 'hi', 'hey', 'good morning', 'good afternoon'],
                'responses': ['Hello! How can I help you today?', 'Hi there! What can I assist you with?']
            },
            'battery_issue': {
                'patterns': ['battery', 'battery life', 'drains fast', 'battery problem'],
                'responses': ['I can help with battery issues. What device are you using?',
                              'Battery problems are common after updates. Let me help.']
            },
            'update_issue': {
                'patterns': ['update', 'ios update', 'software update', 'new version'],
                'responses': ['Updates can sometimes cause issues. What specific problem are you facing?']
            },
            'app_crash': {
                'patterns': ['app crash', 'apps not working', 'freezes', 'apps broken'],
                'responses': ['App crashes can be frustrating. Which apps are having issues?']
            },
            'wifi_issue': {
                'patterns': ['wifi', 'wifi problem', 'internet connection', 'connection issue'],
                'responses': ['I can help with WiFi issues. What seems to be the problem?']
            },
            'shipping_delivery': {
                'patterns': ['shipping', 'delivery', 'package', 'order status'],
                'responses': ['I can check your delivery status. Do you have a tracking number?']
            },
            'thanks': {
                'patterns': ['thank you', 'thanks', 'appreciate', 'helpful'],
                'responses': ['You\'re welcome!', 'Happy to help!', 'Glad I could assist!']
            }
        }
        return patterns

    def train_model(self):
        customer_queries = self.df[self.df['inbound'] == True]['text'].dropna().tolist()
        cleaned_queries = [analyzer.clean_text(query) for query in customer_queries]

        if cleaned_queries:
            self.vectorizer.fit(cleaned_queries)

        return self.vectorizer

trainer = ChatbotTrainer(df)
vectorizer = trainer.train_model()

"""Simple Rule-Based Chatbot"""

class CustomerSupportChatbot:
    def __init__(self, trainer):
        self.trainer = trainer
        self.patterns = trainer.patterns
        self.vectorizer = trainer.vectorizer
        self.context = {}

    def preprocess_input(self, text):
        return analyzer.clean_text(text)

    def find_best_match(self, user_input):
        cleaned_input = self.preprocess_input(user_input)

        for category, data in self.patterns.items():
            for pattern in data['patterns']:
                if pattern in user_input.lower():
                    return category, random.choice(data['responses'])


        if hasattr(self.vectorizer, 'vocabulary_') and cleaned_input:
            try:
                input_vec = self.vectorizer.transform([cleaned_input])
                customer_queries = df[df['inbound'] == True]['text'].dropna().tolist()
                cleaned_queries = [analyzer.clean_text(query) for query in customer_queries]

                if cleaned_queries:
                    query_vecs = self.vectorizer.transform(cleaned_queries)
                    similarities = cosine_similarity(input_vec, query_vecs)
                    best_match_idx = np.argmax(similarities)

                    if similarities[0, best_match_idx] > 0.3:
                        best_response = self.generate_response(customer_queries[best_match_idx])
                        return "similar_issue", best_response
            except:
                pass

        return "unknown", "I'm not sure I understand. Could you please provide more details about your issue?"

    def generate_response(self, similar_query):

        responses = [
            "I understand you're facing an issue. Let me help you with that.",
            "I can assist you with this problem. What specific details can you share?",
            "This seems similar to other issues we've handled. Let me guide you through the solution.",
            "I recognize this type of problem. Here's how we can address it..."
        ]
        return random.choice(responses)

    def chat(self, user_input):
        category, response = self.find_best_match(user_input)


        if category != "unknown":
            self.context['last_topic'] = category

        return response

chatbot = CustomerSupportChatbot(trainer)

""" Test the Chatbot"""

def test_chatbot():
    test_queries = [
        "Hello, I need help with my battery",
        "My phone battery drains too fast",
        "The new update is causing problems",
        "My apps keep crashing",
        "Thank you for your help",
        "What's the weather today?"
    ]

    print("ðŸ¤– CHATBOT TESTING")
    print("=" * 50)

    for query in test_queries:
        response = chatbot.chat(query)
        print(f"User: {query}")
        print(f"Bot: {response}")
        print("-" * 50)

test_chatbot()

""" Advanced Chatbot with Intent Recognition"""

class AdvancedChatbot:
    def __init__(self, df):
        self.df = df
        self.intent_patterns = self._create_intent_patterns()

    def _create_intent_patterns(self):

        return {
            'battery_complaint': {
                'keywords': ['battery', 'drain', 'charge', 'power', 'percent'],
                'entities': ['iphone', 'ios', 'device', 'model'],
                'response_templates': [
                    "I understand your {device} battery is draining quickly. This is common after updates.",
                    "Battery issues with {device} can often be resolved by checking background app activity."
                ]
            },
            'update_problem': {
                'keywords': ['update', 'ios', 'version', 'software', 'new'],
                'entities': ['crash', 'slow', 'bug', 'issue', 'problem'],
                'response_templates': [
                    "Update issues are frequently reported. What specific problem are you facing?",
                    "Many users experience issues after updates. Let me help troubleshoot."
                ]
            },
            'shipping_inquiry': {
                'keywords': ['shipping', 'delivery', 'package', 'order', 'track'],
                'entities': ['late', 'delay', 'status', 'where', 'when'],
                'response_templates': [
                    "I can help with shipping inquiries. Do you have a tracking number?",
                    "Let me check your delivery status. When was your order placed?"
                ]
            },
            'technical_support': {
                'keywords': ['wifi', 'bluetooth', 'connection', 'signal', 'network'],
                'entities': ['drop', 'disconnect', 'slow', 'not working'],
                'response_templates': [
                    "Technical connectivity issues can be complex. Let's diagnose this step by step.",
                    "I can help with {issue} problems. What device are you using?"
                ]
            }
        }

    def extract_entities(self, text):
        entities = {}
        text_lower = text.lower()


        devices = ['iphone', 'ipad', 'macbook', 'samsung', 'android', 'tablet']
        for device in devices:
            if device in text_lower:
                entities['device'] = device
                break

        issues = ['battery', 'wifi', 'bluetooth', 'app', 'update', 'shipping']
        for issue in issues:
            if issue in text_lower:
                entities['issue'] = issue
                break

        return entities

    def classify_intent(self, text):
        text_lower = text.lower()
        best_intent = 'general_help'
        max_matches = 0

        for intent, data in self.intent_patterns.items():
            matches = sum(1 for keyword in data['keywords'] if keyword in text_lower)
            if matches > max_matches:
                max_matches = matches
                best_intent = intent

        return best_intent

    def respond(self, user_input):
        intent = self.classify_intent(user_input)
        entities = self.extract_entities(user_input)

        templates = self.intent_patterns.get(intent, {}).get('response_templates',
                   ["How can I help you today?"])

        response = random.choice(templates)

        for entity, value in entities.items():
            response = response.replace(f'{{{entity}}}', value)

        return response

advanced_bot = AdvancedChatbot(df)

print("ðŸ”§ ADVANCED CHATBOT TEST")
print("=" * 50)
test_inputs = [
    "My iPhone battery is draining very fast after the update",
    "The wifi keeps disconnecting on my Samsung tablet",
    "Where is my package? It's delayed",
    "My apps are crashing after the iOS update"
]

for input_text in test_inputs:
    response = advanced_bot.respond(input_text)
    print(f"User: {input_text}")
    print(f"Bot: {response}")
    print("-" * 50)

"""Create a Streamlit Web Interface for the Chatbot"""

!pip install streamlit streamlit-chat

import streamlit as st
from streamlit_chat import message
import pickle

def create_streamlit_app():
    st.set_page_config(page_title="Customer Support Chatbot", page_icon="ðŸ¤–")

    st.title("ðŸ¤– Customer Support Chatbot")
    st.markdown("""
    Welcome to our 24/7 Customer Support Chatbot!
    I can help you with:
    - Battery and performance issues
    - Software update problems
    - App crashes and technical issues
    - Shipping and delivery inquiries
    - General customer support
    """)


    if 'generated' not in st.session_state:
        st.session_state['generated'] = []
    if 'past' not in st.session_state:
        st.session_state['past'] = []


    def get_text():
        input_text = st.text_input("You: ", "Hello, I need help with...", key="input")
        return input_text

    user_input = get_text()

    if user_input:

        if len(user_input.strip()) > 0:
            response = chatbot.chat(user_input)


            st.session_state.past.append(user_input)
            st.session_state.generated.append(response)

    if st.session_state['generated']:
        for i in range(len(st.session_state['generated'])-1, -1, -1):
            message(st.session_state["generated"][i], key=str(i))
            message(st.session_state['past'][i], is_user=True, key=str(i) + '_user')


with open('streamlit_app.py', 'w') as f:
    f.write('''
import streamlit as st
from streamlit_chat import message
import pandas as pd
import numpy as np
import re
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import random

# Your chatbot code here (simplified for deployment)
class SimpleChatbot:
    def __init__(self):
        self.responses = {
            'greeting': ['Hello! How can I help you?', 'Hi there! What can I assist with?'],
            'battery': ['I can help with battery issues. Try reducing screen brightness.',
                       'Battery draining fast? Check for background apps.'],
            'update': ['Update issues are common. Try restarting your device.',
                      'After updates, some settings might need adjustment.'],
            'shipping': ['I can check delivery status. Do you have tracking info?'],
            'default': ['I understand. Let me help you with that.',
                       'Can you provide more details about your issue?']
        }

    def respond(self, text):
        text_lower = text.lower()
        if any(word in text_lower for word in ['hello', 'hi', 'hey']):
            return random.choice(self.responses['greeting'])
        elif any(word in text_lower for word in ['battery', 'charge', 'drain']):
            return random.choice(self.responses['battery'])
        elif any(word in text_lower for word in ['update', 'ios', 'software']):
            return random.choice(self.responses['update'])
        elif any(word in text_lower for word in ['shipping', 'delivery', 'package']):
            return random.choice(self.responses['shipping'])
        else:
            return random.choice(self.responses['default'])

def main():
    st.set_page_config(page_title="Support Bot", page_icon="ðŸ¤–")
    st.title("ðŸ¤– Customer Support Chatbot")

    chatbot = SimpleChatbot()

    if 'history' not in st.session_state:
        st.session_state.history = []

    user_input = st.text_input("Type your message here:")

    if st.button("Send") and user_input:
        response = chatbot.respond(user_input)
        st.session_state.history.append(("You", user_input))
        st.session_state.history.append(("Bot", response))

    for speaker, text in reversed(st.session_state.history):
        if speaker == "You":
            message(text, is_user=True)
        else:
            message(text)

if __name__ == "__main__":
    main()
''')

print(" Streamlit app created! Run with: streamlit run streamlit_app.py")

""" Export Knowledge Base"""

def create_knowledge_base():
    knowledge_base = {
        'common_issues': {
            'battery_drain': {
                'symptoms': ['Fast battery drain', 'Phone dies quickly', 'Battery percentage drops rapidly'],
                'solutions': ['Reduce screen brightness', 'Close background apps', 'Update to latest iOS', 'Check battery health'],
                'response_templates': [
                    "For battery drain issues, try {solution}",
                    "Many users fix battery problems by {solution}"
                ]
            },
            'app_crashes': {
                'symptoms': ['Apps closing unexpectedly', 'Freezing', 'Not responding'],
                'solutions': ['Update the app', 'Restart device', 'Reinstall app', 'Check for iOS updates'],
                'response_templates': [
                    "For app crashes, I recommend {solution}",
                    "Try {solution} to resolve app instability"
                ]
            },
            'wifi_issues': {
                'symptoms': ['Slow connection', 'Frequent disconnects', 'Cannot connect'],
                'solutions': ['Restart router', 'Forget and reconnect to network', 'Reset network settings'],
                'response_templates': [
                    "WiFi problems can often be fixed by {solution}",
                    "For connectivity issues, try {solution}"
                ]
            }
        },
        'company_responses': {
            'AppleSupport': 'Please check your iOS version and try our troubleshooting steps',
            'SpotifyCares': 'Try logging out and back in, or reinstall the app',
            'VirginTrains': 'Please contact our live chat for immediate assistance'
        }
    }

    with open('knowledge_base.json', 'w') as f:
        json.dump(knowledge_base, f, indent=2)

    return knowledge_base

kb = create_knowledge_base()
print(" Knowledge base created and saved!")

"""Final Summary and Next Steps"""

print("""
ðŸŽ‰ CHATBOT PROJECT COMPLETED!

ðŸ“Š What we've built:
1. Data Analysis - Processed customer support tweets
2. Basic Chatbot - Rule-based with TF-IDF similarity
3. Advanced Chatbot - Intent recognition and entity extraction
4. Web Interface - Streamlit app for deployment
5. Knowledge Base - Common issues and solutions

ðŸš€ Next Steps:
1. Run the Streamlit app locally
2. Connect to Dialogflow for more advanced NLP
3. Deploy to Telegram using BotFather
4. Train on more data for better accuracy
5. Add sentiment analysis for emotional responses

ðŸ”§ To run the web interface:
!pip install streamlit
!streamlit run streamlit_app.py

ðŸ¤– For Dialogflow integration:
- Create account at https://dialogflow.cloud.google.com/
- Import the knowledge_base.json
- Train with sample conversations
- Connect to your preferred platform
""")